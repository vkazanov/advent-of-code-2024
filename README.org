[[https://adventofcode.com/2024][Advent of Code]] 2024 solutions.

2024 is a year of Lua for me.

* Lua as a puzzle solving language

After solving the majority of puzzles using pure Lua and whatever comes with it out of the
box I feel that I have an opinion.

The language is dead simple. Whatever few features it has are carefully picked to make
make the language as expressible as possible. Lua is also superreadable: I had no problems
sharing my solutions with people in private leaderboards.

Favourite things about the language:

- first-class functions/closures

- iterators

- OOP built around hashmaps, dedicated syntax and metatables

- simple equality rules

- truthiness done right: only false and nil are false, everything else is true

- coroutines

- primitive modules

- tail call optimization

Things I hated for Advent of Code purposes:

- global by default?!

- barebones stdlib

- 1-indexed tables

- one and only one data structure

TL;DR not bad, definitely better than Java or C or Go but worse than Python.

* Solutions

** Day 1

[[file:1/part1.lua][Part1]] is about sorting 2 tables and then summing up the differences between smallest to
largest pairs.

time lua part1.lua -> 3ms

[[file:1/part2.lua][Part2]] is just about counting the number of times numbers in the left table appear in the
right table and summing up products of left side numbers and numbers of times they appear
on the right.

Both would basically become code golf excersises in Python, less convenient in Lua.

time lua part1.lua -> 3ms

** Day 2

[[file:2/part1.lua][Part1]] again, a simple code golf task: check if the numbers are either increasing or
descreasing by a given number.

time lua part1.lua -> 2ms

[[file:2/part2.lua][Part2]] same as Part1 but also check if skipping 1 invalid number makes the report correct.
I check the full report first and the look for a number to skip. This n ** 2 but should do
for this particular task.

time lua part2.lua -> 8ms

Notes:

1. Possible to improve by caching safe report subsequences starting with the invalid one
   but no point in do this.

** Day 3

Both parts of [[file:3/][the day]] ask for some regex + maybe something like a virtual machine. Could
have been better with a Perl-like regex engine but still ok.

time lua part1.lua -> 2ms

time lua part2.lua -> 2ms

Notes:

1. Could be speed up by avoid scanning intervals between don't and do but it just doesn't
   make sense at this point

** Day 4 - XMAS search

Sort of [[file:4/][boring again]], looking for lines.

In Part1 I build a list of all diagonal, horizontal and vertical lines, and then grep
through these.

In Part2 I flatten the input into a string and match it against 4 possible patterns.

time lua part1.lua -> 16ms

time lua part2.lua -> 14ms

** Day 5 - rule checking (and a loop)

The [[file:5/][first problem]] that has something interesting in it. The point is to check if rules are
ordered according to a list of ordering list.

In the naive version of Part1 I just check all pairs number pairs against a hash of rules,
which makes O(N*N). Same for fixing in Part2.

time lua part1.lua -> 25ms (part1)

time lua part1.lua -> 1s (part1 + part2)

So instead of direct comparison I switched to using sorting with a custom sorting
function, which is used for both parts:

time lua part1.lua -> 8ms (part1 + part2)

** Day 6 - the guard and the obstacle

On [[file:6/][this day]] the problem was about moving the guard around the map. Part1 works fast even with
a naive approach literal walking approach:

time lua part1.lua -> 10ms

Part2 uses backtracking for loop search with an obstacle, and the native stepping approach
results in bad run time:

time lua part1.lua -> 9s

An improved version that when setting up an obstacle directly jumps to the closest
obstacle instead of walking step by step:

time lua part2-optim.lua -> 300ms

For obstacle indexing I just keep per-line, per-column lists of obstacles. A binary tree
would be better.

** Day 7 - finding the right operators

In [[file:7/][both parts]] the problem boils down to finding the right operators that would make inputs
sum up to an expected number. Left-to-right, same priority, so no complex approaches
necessary. Naive solutions:

time lua part1.lua -> 3ms

time lua part2.lua -> 10s

Notes:

1. might be possible to reuse some of the computation, i.e. using a map of sums to
   remaining numbers.

** Day 8 - antinodes on a grid

On Day 8 the problem needed taking pairs of antennas and marking antinode coordinates in a
set. Could have been cleaner but works fast enough anyways.

time lua part1.lua -> 2ms

time lua part2.lua -> 3ms

** Day 9 - disk fragmentation

The disk fragmentation problem where the program has to rearrange files according to
simple (part1) and slightly more involved rules (part2).

time lua part1.lua -> 27ms

time lua part2.lua -> 90s

The problem with second approach is that I work on bytes directly when representing byte
spans would be much more efficient and readable.

** Day 16

[[file:16/part1.lua][Part 1]] is a pretty boring shortest path problem on a grid with a little twist: a single
step is worth 1 point, while a rotation is a 1000. In practice this means that a graph
node a described by 2 vectors: a position vector and a direction vector. I used a
heap-based Priority Queue to do Dijkstra-style shortest path search.

time lua part1.lua -> 0.5s

In [[file:16/part2.lua][Part 2]] the problem is modified with the additional requirement: count the number of
optimal path nodes. In Dijkstra the optimal path is normally retrieved by storing prev
nodes on all reached nodes including the target one. Getting the optimal path then
requires an additional backwards traversal loop using the prev node links.

Now, because there can be many optimal paths, both diverging and merging, instead of a
single previous node, a set of previous optimal paths should be built along the pathfor
every node.

There are 2 more necessary things: cut out suboptimal paths by tracking best node score.
Upon reaching the final node all the other optimal paths have to be recorded.

time lua part2.lua -> 5s

Notes to myself:

1. both times are too big, the solution needs fixing
2. code is dirty, would benefit from a clean up

* Reference

 - https://garoof.no/notes/aoc-lua.html - a few Lua tricks (vector, foldl, etc)

 - https://explog.in/notes/aoc.html - interesting notes and links

 - https://mmhaskell.com/blog/2023/1/30/advent-of-code-fetching-puzzle-input-using-the-api -
   fetching inputs in Haskell

 - https://github.com/keegancsmith/advent/ - a starting point for utils in [[file:advent.el][advent.el]]
