[[https://adventofcode.com/2024][Advent of Code]] 2024 solutions.

2024 is a year of Lua for me.

* Solutions

** Day 1

[[file:1/part1.lua][Part1]] is about sorting 2 tables and then summing up the differences between smallest to
largest pairs.

time lua part1.lua -> 3ms

[[file:1/part2.lua][Part2]] is just about counting the number of times numbers in the left table appear in the
right table and summing up products of left side numbers and numbers of times they appear
on the right.

Both would basically become code golf excersises in Python, less convenient in Lua.

time lua part1.lua -> 3ms

** Day 2

[[file:2/part1.lua][Part1]] again, a simple code golf task: check if the numbers are either increasing or
descreasing by a given number.

time lua part1.lua -> 2ms

[[file:2/part2.lua][Part2]] same as Part1 but also check if skipping 1 invalid number makes the report correct.
I check the full report first and the look for a number to skip. This n ** 2 but should do
for this particular task.

time lua part2.lua -> 8ms

Notes:

1. Possible to improve by caching safe report subsequences starting with the invalid one
   but no point in do this.

** Day 3

Both parts of [[file:3/][the day]] ask for some regex + maybe something like a virtual machine. Could
have been better with a Perl-like regex engine but still ok.

time lua part1.lua -> 2ms
time lua part2.lua -> 2ms

Notes:

1. Could be speed up by avoid scanning intervals between don't and do but it just doesn't
   make sense at this point

** Day 4 - XMAS search

Sort of [[file:4/][boring again]], looking for lines.

In Part1 I build a list of all diagonal, horizontal and vertical lines, and then grep
through these.

In Part2 I flatten the input into a string and match it against 4 possible patterns.

time lua part1.lua -> 16ms
time lua part2.lua -> 14ms

** Day 5 - rule checking (and a loop)

The [[file:5/][first problem]] that has something interesting in it. The point is to check if rules are
ordered according to a list of ordering list.

In the naive version of Part1 I just check all pairs number pairs against a hash of rules,
which makes O(N*N). Same for fixing in Part2.

time lua part1.lua -> 25ms (part1)
time lua part1.lua -> 1s (part1 + part2)

So instead of direct comparison I switched to using sorting with a custom sorting
function, which is used for both parts:

time lua part1.lua -> 8ms (part1 + part2)

** Day 16

[[file:16/part1.lua][Part 1]] is a pretty boring shortest path problem on a grid with a little twist: a single
step is worth 1 point, while a rotation is a 1000. In practice this means that a graph
node a described by 2 vectors: a position vector and a direction vector. I used a
heap-based Priority Queue to do Dijkstra-style shortest path search.

time lua part1.lua -> 0.5s

In [[file:16/part2.lua][Part 2]] the problem is modified with the additional requirement: count the number of
optimal path nodes. In Dijkstra the optimal path is normally retrieved by storing prev
nodes on all reached nodes including the target one. Getting the optimal path then
requires an additional backwards traversal loop using the prev node links.

Now, because there can be many optimal paths, both diverging and merging, instead of a
single previous node, a set of previous optimal paths should be built along the pathfor
every node.

There are 2 more necessary things: cut out suboptimal paths by tracking best node score.
Upon reaching the final node all the other optimal paths have to be recorded.

time lua part2.lua -> 5s

Notes to myself:

1. both times are too big, the solution needs fixing
2. code is dirty, would benefit from a clean up

* Reference

 - https://garoof.no/notes/aoc-lua.html - a few Lua tricks (vector, foldl, etc)

 - https://explog.in/notes/aoc.html - interesting notes and links

 - https://mmhaskell.com/blog/2023/1/30/advent-of-code-fetching-puzzle-input-using-the-api -
   fetching inputs in Haskell

 - https://github.com/keegancsmith/advent/ - a starting point for utils in [[file:advent.el][advent.el]]
