[[https://adventofcode.com/2024][Advent of Code]] 2024 solutions.

2024 is a year of Lua for me.

* Solutions

** Day 1

[[file:1/part1.lua][Part1]] is about sorting 2 tables and then summing up the differences between smallest to
largest pairs.

time lua part1.lua -> 3ms

[[file:1/part2.lua][Part2]] is just about counting the number of times numbers in the left table appear in the
right table and summing up products of left side numbers and numbers of times they appear
on the right.

Both would basically become code golf excersises in Python, less convenient in Lua.

time lua part1.lua -> 3ms

** Day 2

[[file:2/part1.lua][Part1]] again, a simple code golf task: check if the numbers are either increasing or
descreasing by a given number.

time lua part1.lua -> 2ms

[[file:2/part2.lua][Part2]] same as Part1 but also check if skipping 1 invalid number makes the report correct.
I check the full report first and the look for a number to skip. This n ** 2 but should do
for this particular task.

time lua part2.lua -> 8ms

Notes:

1. Possible to improve by caching safe report subsequences starting with the invalid one
   but no point in do this.

** Day 16

[[file:16/part1.lua][Part 1]] is a pretty boring shortest path problem on a grid with a little twist: a single
step is worth 1 point, while a rotation is a 1000. In practice this means that a graph
node a described by 2 vectors: a position vector and a direction vector. I used a
heap-based Priority Queue to do Dijkstra-style shortest path search.

time lua part1.lua -> 0.5s

In [[file:16/part2.lua][Part 2]] the problem is modified with the additional requirement: count the number of
optimal path nodes. In Dijkstra the optimal path is normally retrieved by storing prev
nodes on all reached nodes including the target one. Getting the optimal path then
requires an additional backwards traversal loop using the prev node links.

Now, because there can be many optimal paths, both diverging and merging, instead of a
single previous node, a set of previous optimal paths should be built along the pathfor
every node.

There are 2 more necessary things: cut out suboptimal paths by tracking best node score.
Upon reaching the final node all the other optimal paths have to be recorded.

time lua part2.lua -> 5s

Notes to myself:

1. both times are too big, the solution needs fixing
2. code is dirty, would benefit from a clean up

* Reference

 - https://garoof.no/notes/aoc-lua.html - a few Lua tricks (vector, foldl, etc)

 - https://explog.in/notes/aoc.html - interesting notes and links

 - https://mmhaskell.com/blog/2023/1/30/advent-of-code-fetching-puzzle-input-using-the-api -
   fetching inputs in Haskell

 - https://github.com/keegancsmith/advent/ - a starting point for utils in [[file:advent.el][advent.el]]
